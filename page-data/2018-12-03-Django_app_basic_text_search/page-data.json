{"componentChunkName":"component---src-templates-blog-post-js","path":"/2018-12-03-Django_app_basic_text_search/","result":{"data":{"markdownRemark":{"html":"<p>Checking the dependencies on my Django demo app from time to time to time on Heroku, I noticed a few packages were out of date. So while I got to updating all packages to the most recent stable versions, I found the app to be lacking a popular option for searching basic text records. Thus I began looking into my options of what searches to implement. There were high end packages like Elastisearch, but ultimately I wanted this feature and my code base to remain portable, so I decided to remain with native Python and Django implementations. After some investigation, I found in the official documentation that Django has built-in support for full text search as of v2.1, with the only requirement being that the project uses PostgreSQL.</p>\n<p>My Django demo app repository can be found <a href=\"https://github.com/sbhaseen/django_web_app_demo\">here</a>.</p>\n<p>Some good references that help implementing this basic text search:</p>\n<ul>\n<li><a href=\"https://docs.djangoproject.com/en/2.1/ref/contrib/postgres/search/\">Django - Full text search</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/2.1/topics/db/queries/\">Django - Making queries</a></li>\n<li><a href=\"https://www.postgresql.org/docs/current/textsearch.html\">PostgreSQL - Full text search</a></li>\n</ul>\n<p>Some additional setup was required as my initial project was using SQLite to test locally, even though my Heroku deployment is on PostgreSQL. So I quickly setup a Postgres development environment and transferred my project over to Postgres local development as well. I also learned a bit about transferring databases using CSV files, but that's probably for another post.</p>\n<hr>\n<h2>Adding Search Queries</h2>\n<h3>Views.py</h3>\n<p>The first thing to do was to setup a class based view that inherits the properties of the base Book model in the app's views.py.</p>\n<p>Over here, a special template named \"book<em>search.html\" is overriding the base \"book</em>list.html\" to differentiate results to users. Although in theory, the basic \"book_list.html\" can be used if it is made generic enough, it probably would not scale well if the website had things other than books to display.</p>\n<p>To run though the logic quickly, this is what happens:</p>\n<ol>\n<li>A Book-object query with all results is initialized.</li>\n<li>A <code>keyword</code> variable is initialized based on a search query input from the navbar.</li>\n<li>If a search query (keyword) is detected, the special Django built-in function <code>SearchQuery()</code> if applied to the <code>keyword</code> input.</li>\n<li>A <code>SearchVector()</code> function is applied to the fields of the Book model that are desired to be searched. In this case I limited it to the use of Author name, title, summary and genre.</li>\n<li>The <code>SearchVector()</code> is then applied with a filter containing the <code>query</code> of keywords.</li>\n<li>The built in <code>SearchRank()</code> function is used to try and list the most relevant results first.</li>\n</ol>\n<p>The code looks as follows:</p>\n<pre><code class=\"language-python\">...\nfrom django.contrib.postgres.search import SearchQuery, SearchRank, SearchVector\n\n\nclass BookSearchListView(generic.ListView):\n    \"\"\"\n    Display a Book List page filtered by the search query.\n    \"\"\"\n    model = Book\n    paginate_by = 10\n    template_name = 'catalog/book_search.html'\n\n    def get_queryset(self):\n        qs = Book.objects.all()\n\n        keywords = self.request.GET.get('q')\n        if keywords:\n            query = SearchQuery(keywords)\n            # ManyToMany or ForeignKey fields need (double underscore) lookup type to work: in this case __name\n            vector = SearchVector('author__first_name',\n                                  'author__last_name',\n                                  'title',\n                                  'summary',\n                                  'genre__name')\n            qs = qs.annotate(search=vector).filter(search=query)\n            qs = qs.annotate(rank=SearchRank(vector, query)).order_by('-rank')\n\n        return qs\n</code></pre>\n<h3>Urls.py</h3>\n<p>After adding the new search view, the urls.py has to be configured to setup the search results. This was pretty straight forward and only needed one addition to the existing <code>urlpatterns</code> list.</p>\n<pre><code class=\"language-python\">urlpatterns = [\n    ...\n    path('search/', views.BookSearchListView.as_view(), name='search'),\n]\n</code></pre>\n<h3>The search results template: book_search.html</h3>\n<p>After configuring the urls.py, it was time to make the template for the search results. As mentioned earlier, I could reuse the base model template, but wanted to separate the results in case I decide to expand general search functionality in the future.</p>\n<p>This template is actually exactly the same as the \"book_list.html\", except the header is set to \"Book Search Results\" and the failure statement returns \"The search did not find any results\".</p>\n<p>One important modification was to show the search query that a user input, which can be done easily with the <code>request.GET</code> method.</p>\n<pre><code class=\"language-html\">...\n&#x3C;p>The results of the search query: {% raw %}{{ request.GET.q }}{% endraw %}&#x3C;/p>\n...\n</code></pre>\n<h3>Adding a test for the new search view: test_views.py</h3>\n<p>Test driven development is something I like to work within as it keeps up good coding practice and documentation. In this case, I added tests that will ensure proper search functionality.</p>\n<p>The test will setup some dummy book instances and then test the following:</p>\n<ul>\n<li>The url is properly redirected</li>\n<li>The correct template is used for search results</li>\n<li>The individual fields of the Book model are properly queried: Author, title, summary and genre. It also test that no results are retunred in case of an out-of-scope search query.</li>\n</ul>\n<pre><code class=\"language-python\">...\n# Test basic text search functionality\nclass SearchBooksListViewTest(TestCase):\n    def setUp(self):\n        test_author = Author.objects.create(first_name='John', last_name='Smith')\n        test_genre = Genre.objects.create(name='Science Fiction')\n        test_language = Language.objects.create(name='English')\n        test_book = Book.objects.create(\n            title='Book Title',\n            summary='My book summary has interesting stories of machines and robots',\n            isbn='1234567890123',\n            author=test_author,\n            language=test_language,\n        )\n\n        # Create genre as a post-step\n        genre_objects_for_book = Genre.objects.all()\n        test_book.genre.set(genre_objects_for_book) # Direct assignment of many-to-many types not allowed.\n        test_book.save()\n\n        # Create 30 BookInstance objects\n        number_of_book_copies = 30\n        for book_copy in range(number_of_book_copies):\n            status = 'a'\n            BookInstance.objects.create(\n                book=test_book,\n                imprint='Unlikely Imprint, 2016',\n                status=status,\n            )\n\n    def test_uses_correct_template(self):\n        # Check that urls.py is configured correctly\n        response = self.client.get(reverse('search'))\n\n        # Check response was a \"success\"\n        self.assertEqual(response.status_code, 200)\n\n        # Check correct template used\n        self.assertTemplateUsed(response, 'catalog/book_search.html')\n\n    def test_search_function_redirect_and_query(self):\n        \"\"\"\n        The search class based view `BookSearchListView` in views.py queries\n        these SearchVectors from the Book model: author, title, summary, genre\n        \"\"\"\n        # Check author returns a book\n        resp = self.client.get('/catalog/search/', {'q': 'john smith'})\n        self.assertEqual(resp.status_code, 200)\n        self.assertTrue(len(resp.context['book_list']) > 0)\n\n        # Check title returns a book\n        resp = self.client.get('/catalog/search/', {'q': 'book title'})\n        self.assertEqual(resp.status_code, 200)\n        self.assertTrue(len(resp.context['book_list']) > 0)\n\n        # Check summary returns a book\n        resp = self.client.get('/catalog/search/', {'q': 'machine'})\n        self.assertEqual(resp.status_code, 200)\n        self.assertTrue(len(resp.context['book_list']) > 0)\n\n        # Check genre returns a book\n        resp = self.client.get('/catalog/search/', {'q': 'fiction'})\n        self.assertEqual(resp.status_code, 200)\n        self.assertTrue(len(resp.context['book_list']) > 0)\n\n        # Check out of scope search does not return any book\n        resp = self.client.get('/catalog/search/', {'q': 'drama'})\n        self.assertEqual(resp.status_code, 200)\n        self.assertTrue(len(resp.context['book_list']) == 0)\n</code></pre>\n<p>And with that, the site now has basic text search!</p>\n<p>Update: This project was formely hosted on Heroku, but is now archieved for reference code only.</p>\n<p>A screenshot for fun:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/436b5594c619c8bdb1c0e4f7a0e453eb/a95f7/django_app_search_01.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.57142857142857%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABHklEQVQoz+WO2UrDQBiF5wXbbJXYB8kj2CXNohZaVBR9BEF8BaXSXrp0Sy6k0MlCgzWNYnKcDArjlSjeeeDjzBz+/8wQy7bR6/VhGAZkuQpNUSBVKpAlCYos83td11Hf1rGlaaip6hdUNsPnqxJqsgRyeHKGg+NTdPtHaNkumqaDBqPZcdGyXLTtXZj2Hqfj7HNMhuV2sdO2cH5xibnnYzAcoeE6IJQGWFKKIAyZB7gbzxhT7veTOa4GQ1zfjDjluczGMx8PU48ThBGe1muskgRRHINAUFEU8BcRbn2KifeIxTIEjRPQaCWQfGQJAuZ5XogVIGXJJ3meI81e8ZxmSDcZNtnLt7yxHbGDiL/7rcRdIgbiSz9B7CD4Y/3DwndimSIFCySdfgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"app screenshot\"\n        title=\"app screenshot\"\n        src=\"/static/436b5594c619c8bdb1c0e4f7a0e453eb/8c557/django_app_search_01.png\"\n        srcset=\"/static/436b5594c619c8bdb1c0e4f7a0e453eb/4edbd/django_app_search_01.png 175w,\n/static/436b5594c619c8bdb1c0e4f7a0e453eb/13ae7/django_app_search_01.png 350w,\n/static/436b5594c619c8bdb1c0e4f7a0e453eb/8c557/django_app_search_01.png 700w,\n/static/436b5594c619c8bdb1c0e4f7a0e453eb/e996b/django_app_search_01.png 1050w,\n/static/436b5594c619c8bdb1c0e4f7a0e453eb/2cefc/django_app_search_01.png 1400w,\n/static/436b5594c619c8bdb1c0e4f7a0e453eb/a95f7/django_app_search_01.png 1853w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>","frontmatter":{"date":"December 03, 2018","title":"Django App Basic Text Search","tags":["Python","Django","PostgreSQL","text search"]}}},"pageContext":{"slug":"/2018-12-03-Django_app_basic_text_search/"}},"staticQueryHashes":["63159454"]}