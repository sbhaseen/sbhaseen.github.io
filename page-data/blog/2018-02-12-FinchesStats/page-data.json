{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2018-02-12-FinchesStats/","result":{"data":{"markdownRemark":{"html":"<p>Data: Darwin's finches on Daphne Major Island.<br>\nMethods: Graphical and quantitative EDA, parameter estimation, confidence interval calculation &#x26; hypothesis testing.</p>\n<hr>\n<h2>An analysis of evolutionary data of finches scandens and fortis.</h2>\n<p>This is a my own take on a case study from a DataCamp.com course on Statistical Thinking, Part 2.<br>\nThe Jupyter notebook can be found <a href=\"https://github.com/sbhaseen/Python/blob/master/Notebook_FinchesStats/Notebook_FinchesStatsRedux.ipynb\">here</a>.</p>\n<h3>Original data publication:</h3>\n<p>Grant, PR, Grant, BR (2014) 40 years of evolution:<br>\nDarwin's finches on Daphne Major Island.<br>\nPrinceton: Princeton University Press. <a href=\"https://doi.org/\">https://doi.org/</a></p>\n<p>Dryad data package:</p>\n<p>Grant PR, Grant BR (2014) Data from: 40 years of evolution.<br>\nDarwin's finches on Daphne Major Island.<br>\nDryad Digital Repository. <a href=\"https://doi.org/10.5061/dryad.g6g3h\">https://doi.org/10.5061/dryad.g6g3h</a></p>\n<h3>Importing and cleaning data from CSV files</h3>\n<pre><code class=\"language-python\">%matplotlib inline\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfinches_1975 = pd.read_csv('datasets/finch_beaks_1975.csv',\n                           usecols=['species',\n                                    'Beak length, mm',\n                                    'Beak depth, mm'])\nfinches_1975.rename(columns={'Beak depth, mm': 'bdepth',\n                             'Beak length, mm': 'blength'}, inplace=True)\nfinches_1975['year'] = 1975\n\nfinches_2012 = pd.read_csv('datasets/finch_beaks_2012.csv',\n                           usecols=['species',\n                                    'blength',\n                                    'bdepth'])\nfinches_2012['year'] = 2012\n\nfinches = pd.concat([finches_1975, finches_2012], ignore_index=True)\n</code></pre>\n<h3>Perform an exploratory data analysis (EDA) of beak depth for G. scandens 1975 vs. 2012</h3>\n<pre><code class=\"language-python\">sns.set()  # Set Seaborn default plot style\n\n# Isolating scandens beak depth, bdepth\ny = finches.loc[finches['species'] == 'scandens', 'bdepth']\nsns.swarmplot(x='year', y=y, data=finches)\nplt.title('G. scandens Beak Depth: 1975 vs. 2012')\nplt.xlabel('Year')\nplt.ylabel('Beak depth (mm)');\n</code></pre>\n<p><img src=\"../images/blog/FinchesStats01.png\" alt=\"finch beak depth\"></p>\n<h3>Functions to help the analysis</h3>\n<pre><code class=\"language-python\"># Function definitions\n\n\ndef ecdf(data):\n    \"\"\"\n    Compute the empirical cumulative distribution function (ECDF)\n    for a one-dimensional array of data.\n    Params: data\n    \"\"\"\n\n    n = len(data)  # Number of data points\n    x = np.sort(data)\n    y = np.arange(1, n+1) / n\n\n    return x, y\n\n\ndef draw_bs_reps(data, func, size=1):\n    \"\"\"\n    Draw bootstrap replicates for a given size and apply Numpy functions.\n    Params: data, func, size\n    \"\"\"\n\n    bs_replicates = np.empty(size)\n\n    for i in range(size):\n        bs_replicates[i] = func(np.random.choice(data, size=len(data)))\n\n    return bs_replicates\n\n\ndef draw_bs_pairs_linreg(x, y, size=1):\n    \"\"\"\n    Perform pairs bootstrap for linear regression.\n    Params: x-data, y-data, size\n    \"\"\"\n\n    # Set up array of indices to sample from: inds\n    inds = np.arange(len(x))\n\n    # Initialize replicates\n    bs_slope_reps = np.empty(size)\n    bs_intercept_reps = np.empty(size)\n\n    # Generate replicates\n    for i in range(size):\n        bs_inds = np.random.choice(inds, size=len(inds))\n        bs_x, bs_y = x[bs_inds], y[bs_inds]\n        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, 1)\n\n    return bs_slope_reps, bs_intercept_reps\n</code></pre>\n<p>Here, I compute and plot the emperical cumulative distribution fuction (ECFD) of G. scandens beak measurements.<br>\nThis gives an overview of the data so I can pick out some features and trends.</p>\n<pre><code class=\"language-python\"># Convert dataframes data to arrays for computation\nbd_1975 = np.array(finches.loc[(finches['species'] == 'scandens') &#x26;\n                               (finches['year'] == 1975),\n                               'bdepth'])\nbd_2012 = np.array(finches.loc[(finches['species'] == 'scandens') &#x26;\n                               (finches['year'] == 2012),\n                               'bdepth'])\nx_1975, y_1975 = ecdf(bd_1975)\nx_2012, y_2012 = ecdf(bd_2012)\n\nplt.plot(x_1975, y_1975, marker='.', linestyle='none')\nplt.plot(x_2012, y_2012, marker='.', linestyle='none')\nplt.margins(0.02)\nplt.title('ECDF of G. scandens Beak Depth: 1975 vs. 2012')\nplt.ylabel('ECDF')\nplt.legend(('1975', '2012'), loc='lower right');\n</code></pre>\n<p><img src=\"../images/blog/FinchesStats02.png\" alt=\"Emperical Cumulative Distribution Fuction plot\"></p>\n<h3>Parameter estimation of the mean difference between 1975 and 2012 data.</h3>\n<p>A random seed value of seed(42) is used for reproducibility.<br>\nFor bootstrap data, a sample of 10,000 tries is used.<br>\nThe results are then compared to the 95% confidence interval.</p>\n<pre><code class=\"language-python\">np.random.seed(42)\n\nmean_diff = np.mean(bd_2012) - np.mean(bd_1975)\n\nbs_replicates_1975 = draw_bs_reps(bd_1975, np.mean, 10000)\nbs_replicates_2012 = draw_bs_reps(bd_2012, np.mean, 10000)\n\nbs_diff_replicates = bs_replicates_2012 - bs_replicates_1975\nconf_int = np.percentile(bs_diff_replicates, [2.5, 97.5])\n\nprint('Difference of means =', mean_diff, 'mm')\nprint('95% confidence interval =', conf_int, 'mm')\n</code></pre>\n<pre><code class=\"language-shell\">Difference of means = 0.226220472441 mm\n95% confidence interval = [ 0.05633521  0.39190544] mm\n</code></pre>\n<p>A result of 0.2 mm difference between the means of 2012 and 1975 is observed.<br>\nThis result lies between the 95% confidence interval of 0.05 to 0.38 mm.</p>\n<h2>Hypothesis test: Are beaks deeper in 2012?</h2>\n<h3>Null hypothesis: The means of 2012 and 1975 are equal.</h3>\n<p>-Is this observation just due to random chance<br>\n-What is the probability that one would observe the same or greater difference\nin mean beak depth if the means were the same (p-value)</p>\n<p>To perform this hypothesis test, the two data sets are shifted such that they have the same mean.\nFollowing that, a bootstrap sampling method of 10,000 samples is used to compute a new random difference of means.</p>\n<pre><code class=\"language-python\">combined_mean = np.mean(np.concatenate((bd_1975, bd_2012)))\n\nbd_1975_shifted = bd_1975 - np.mean(bd_1975) + combined_mean\nbd_2012_shifted = bd_2012 - np.mean(bd_2012) + combined_mean\n\nbs_replicates_1975 = draw_bs_reps(bd_1975_shifted, np.mean, 10000)\nbs_replicates_2012 = draw_bs_reps(bd_2012_shifted, np.mean, 10000)\n\nbs_diff_replicates = bs_replicates_2012 - bs_replicates_1975\n\np = np.sum(bs_diff_replicates >= mean_diff) / len(bs_diff_replicates)\n\nprint('P-value of hypothesis test: p =', p)\n</code></pre>\n<pre><code class=\"language-shell\">P-value of hypothesis test: p = 0.0037\n</code></pre>\n<p>A p-value of 0.0037 is calculated, which suggests that there is a\nstatistically significant difference and the null hypotheses can be rejected.<br>\nCombining this with the difference of 0.2 mm between the means suggest\na change by 0.2 mm in 37 years (1975 to 2012).</p>\n<h2>EDA of beak length and depth</h2>\n<p>The beak length and depth are compared to determine if there exists a correlation.</p>\n<pre><code class=\"language-python\"># Extracting beak length (blength) from original Data Frame\nbl_1975 = np.array(finches.loc[(finches['species'] == 'scandens') &#x26;\n                               (finches['year'] == 1975),\n                               'blength'])\nbl_2012 = np.array(finches.loc[(finches['species'] == 'scandens') &#x26;\n                               (finches['year'] == 2012),\n                               'blength'])\n\n# Make scatter plots of 1975 &#x26; 2012 data\n\nplt.plot(bl_1975, bd_1975, marker='.',\n         linestyle='none', color='blue', alpha=0.5)\n\nplt.plot(bl_2012, bd_2012, marker='.',\n         linestyle='none', color='red', alpha=0.5)\n\nplt.title('Beak Depth vs. Beak Length G. scandens: 1975 &#x26; 2012')\nplt.xlabel('Beak length (mm)')\nplt.ylabel('Beak depth (mm)')\nplt.legend(('1975', '2012'), loc='upper left');\n</code></pre>\n<p><img src=\"../images/blog/FinchesStats03.png\" alt=\"Beak depth vs length\"></p>\n<p>From the plot, we see that beaks got deeper but not much longer.</p>\n<h2>Perform a linear regression of the beak length and depth</h2>\n<p>First, the linear regressions of 1975 and 2012 data are computed.\nThen a paris bootstrap sampling of 1000 linear gresressions is perfromed.\nFollowing that, the 95% confidence interval of the bootstrap linear regression solpes and intercepts are dertermined.</p>\n<pre><code class=\"language-python\">slope_1975, intercept_1975 = np.polyfit(bl_1975, bd_1975, 1)\nslope_2012, intercept_2012 = np.polyfit(bl_2012, bd_2012, 1)\n\nbs_slope_reps_1975, bs_intercept_reps_1975 = \\\n        draw_bs_pairs_linreg(bl_1975, bd_1975, 1000)\nbs_slope_reps_2012, bs_intercept_reps_2012 = \\\n        draw_bs_pairs_linreg(bl_2012, bd_2012, 1000)\n\nslope_conf_int_1975 = np.percentile(bs_slope_reps_1975, [2.5, 97.5])\nslope_conf_int_2012 = np.percentile(bs_slope_reps_2012, [2.5, 97.5])\nintercept_conf_int_1975 = np.percentile(bs_intercept_reps_1975, [2.5, 97.5])\nintercept_conf_int_2012 = np.percentile(bs_intercept_reps_2012, [2.5, 97.5])\n\nprint('1975: slope =', slope_1975,\n      '95% conf int =', slope_conf_int_1975)\nprint('1975: intercept =', intercept_1975,\n      '95% conf int =', intercept_conf_int_1975)\nprint('2012: slope =', slope_2012,\n      '95% conf int =', slope_conf_int_2012)\nprint('2012: intercept =', intercept_2012,\n      '95% conf int =', intercept_conf_int_2012)\n</code></pre>\n<pre><code class=\"language-shell\">1975: slope = 0.465205169161 95% conf int = [ 0.32895048  0.59051248]\n1975: intercept = 2.39087523658 95% conf int = [ 0.56980654  4.32921979]\n2012: slope = 0.462630358835 95% conf int = [ 0.33013404  0.5971864 ]\n2012: intercept = 2.97724749824 95% conf int = [ 1.15904983  4.74841692]\n</code></pre>\n<p>The linear regression data is then plotted.</p>\n<pre><code class=\"language-python\">plt.plot(bl_1975, bd_1975, marker='.',\n         linestyle='none', color='blue', alpha=0.5)\n\nplt.plot(bl_2012, bd_2012, marker='.',\n         linestyle='none', color='red', alpha=0.5)\n\nplt.title('Linear regressions of G. scandens beak depth vs length')\nplt.xlabel('beak length (mm)')\nplt.ylabel('beak depth (mm)')\nplt.legend(('1975', '2012'), loc='upper left')\n\n# Generate x-values for bootstrap line plots\nx = np.array([10, 17])\n\n# Plot the bootstrap lines\nfor i in range(100):\n    plt.plot(x, bs_slope_reps_1975[i] * x + bs_intercept_reps_1975[i],\n             linewidth=0.5, alpha=0.2, color='blue')\n    plt.plot(x, bs_slope_reps_2012[i] * x + bs_intercept_reps_2012[i],\n             linewidth=0.5, alpha=0.2, color='red')\n</code></pre>\n<p><img src=\"../images/blog/FinchesStats04.png\" alt=\"linear regression of beak depth vs length\"></p>\n<h2>Exploring the beak length and depth ratio</h2>\n<p>The beak length and depth are copared to see how the values changed together.\nFirstly, the original data is compared, then a bootstrap sampling of 10,000 is used to determine a 99% confidence interval.</p>\n<pre><code class=\"language-python\">ratio_1975 = bl_1975 / bd_1975\nratio_2012 = bl_2012 / bd_2012\n\nmean_ratio_1975 = np.mean(ratio_1975)\nmean_ratio_2012 = np.mean(ratio_2012)\n\n# Generate bootstrap replicates of the means for 10,000 samples\nbs_replicates_1975 = draw_bs_reps(ratio_1975, np.mean, 10000)\nbs_replicates_2012 = draw_bs_reps(ratio_2012, np.mean, 10000)\n\n# Compute the 99% confidence intervals\nconf_int_1975 = np.percentile(bs_replicates_1975, [0.5, 99.5])\nconf_int_2012 = np.percentile(bs_replicates_2012, [0.5, 99.5])\n\nprint('1975: mean ratio =', mean_ratio_1975,\n      '99% conf int =', conf_int_1975)\nprint('2012: mean ratio =', mean_ratio_2012,\n      '99% conf int =', conf_int_2012)\n</code></pre>\n<pre><code class=\"language-shell\">1975: mean ratio = 1.57888237719 99% conf int = [ 1.55651998  1.60112118]\n2012: mean ratio = 1.46583422768 99% conf int = [ 1.4448795   1.48772402]\n</code></pre>\n<p>The mean beak length-to-depth ratio decreased by about 0.1 from 1975 to 2012.\nThe 99% confidence intervals are not overlapping, which indicates that the beak shape changed.</p>","frontmatter":{"date":"February 12, 2018","title":"Statistics and Finch Evolution","tags":["Python","statistics","data analysis"]}}},"pageContext":{"slug":"/blog/2018-02-12-FinchesStats/","previous":{"fields":{"collection":"blog","slug":"/blog/2018-11-02-Django_web_app_demo/"},"frontmatter":{"title":"Django web app demo"}},"next":{"fields":{"collection":"blog","slug":"/blog/2018-12-03-Django_app_basic_text_search/"},"frontmatter":{"title":"Django App Basic Text Search"}}}},"staticQueryHashes":["63159454"]}